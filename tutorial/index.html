<html>
<head>
    <title>Akka cluster with CQRS and eventsourcing</title>
</head>
<body>
<div>
    <h2>Introduction</h2>
    <p>
    This activator template will show how to make a CQRS (Command Query Responsibility Segregation) style application using akka-persistence and cluster sharding with an PersistentActor and PersistentView.
    CQRS stands for Command Query Responsibility Segregation. It's a pattern that was first described by Greg Young. Basically it means that you use a different model to update information than the model you use to read information.
        There are two different kind of messages in a CQRS system:
    </p>
    <dl>
        <dt>Commands</dt>
        <dd>change the state of an object</dd>
        <dt>Queries</dt>
        <dd>return results and do not change the state of an object</dd>
    </dl>
    <p>
    Event Sourcing means that all changes to application state are stored as a sequence of events. This sequence of events can be used to query the current state of an object, and the history of an object.
        It is also a great help for queries you did not think of when creating your application. Because all events are stored, you can query for everything imaginable with the data.
    </p>
    <p>
    We believe that the Akka actor model is an extremely good fit for CQRS and Event sourcing. The actor works on the basis of processing a command and outputting one or many events that represent the result of processing that command.
</p><p>
    Akka <a href="http://doc.akka.io/docs/akka/2.3.5/common/cluster.html#cluster">cluster</a> will be used to create a distributed system.
</p><p>
    In this tutorial we will present a business case which we will implement with Akka incl. clustering, CQRS and Event Sourcing.
    </p>
</div>



<div>
    <h2>The Business Case</h2>
    <p>
        This case will illustrate how a customer can submit an order containing multiple order lines per product.
        The process flow is as follows:
        </p>
    <ol>
        <li>A user creates an order. Client is sending a createOrderForUser command with the username and orderId</li>
        <li>The user adds one or more order lines (products) to the order (addProductToOrder)</li>
        <li>The user finalizes the sale by submitting the order (placeOrder)</li>
    </ol>
<p>
        Business rules:
</p>
    <ul>

        <li>A user is allowed to have one active order at a time</li>
        <li>A user is allowed to have a maximum order value of 100 dollars</li>
    </ul>
<p>
        Admins or other user(s) (ie finance department, shipping, logistics, etc) can see what happened to the order to allow them to track the order flow.
</p>
<p>Implementation:<br>
       This is implemented by a CQRS model with Clustering, as depicted below
        <img src="tutorial/images/cqrs.png">
</p>
    </p>
</div>



<div>
    <h2>Domain</h2>
    <p>
        To perform an action in the domain, you have to send a command to it. The command will be validated and processed. This will lead to one or more events that are stored in the journal. This is the Command part of <b>C</b>QRS with Event Sourcing.
    </p>
    <p>
        In the domain we have 3 important Actors for handling the business logic. These actors are created in the <a href="#code/src/main/scala/cqrs/DomainActors.scala" class="shortcut">DomainActors</a> Trait
        <ul>
            <li><a href="#code/src/main/scala/cqrs/domain/orders/Orders.scala" class="shortcut">Orders</a>: This is a cluster singleton and contains the collection of orders. We need this actor (and it should be
                a singleton) to keep track of the orders in our system. This will become more clear in the View. In your real world application you could for example use it to instantiate the existing orders again when your
                application is started.
            </li>
            <li><a href="#code/src/main/scala/cqrs/domain/orders/Order.scala" class="shortcut">Order</a>: This is an order domain object that contains all logic concerning the order. The Order Actors are sharded
                over the available nodes.
            </li>
            <li><a href="#code/src/main/scala/cqrs/domain/orders/OrderCommandHandler.scala" class="shortcut">OrderCommandHandler</a>: The OrderCommandHandler is running on every node. It will handle
                all commands concerning orders that are sent to the domain. The handler does this by sending the command to the Orders singleton, or to the Order directly.
            </li>
        </ul>
    </p>
</div>
<div>
    <h2>View</h2>
    <p>
        To create a view of the domain model (which is eventsourced) you have to collect the events and process them into a view. This can be done with PersistentView. The problem with PersistentView is that it can only
        operate on a single persistenceId. 
    </p>
    <p>In our example we want to get an overview of all orders. To achieve this we create an <a href="#code/src/main/scala/cqrs/read/OrdersView.scala" class="shortcut">OrdersView</a> that
        will create a <a href="#code/src/main/scala/cqrs/read/OrderView.scala" class="shortcut">OrderView</a> for every order in the system. The OrderView will forward all events to its parent (the OrdersView). This way the
        OrdersView will receive all events from all orders in the system and can create the views in any way it likes.
    </p>

</div>
<div>
    <h2>Testing</h2>
    <p>
        For testing we prefer FlatSpec for Component testing and FeatureSpec with <em>GivenWhenThen</em> for testing User Stories (Functional and integration tests).
        For other available test styles in Scalatest see: <a href="http://www.scalatest.org/user_guide/selecting_a_style">http://www.scalatest.org/user_guide/selecting_a_style</a>.
</p><p>
        FeatureSpec with <em>GivenWhenThen</em> enables you to write BDD-style tests.
        BDD-style tests represent a higher level of abstraction than Unit tests, and are more suitable for integration and acceptance testing as well as documentation.
       </p> <p>
        <h3>Domain Test</h3>
    <p>
        In the <a href="#code/src/test/scala/cqrs/domain/orders/DomainTest.scala" class="shortcut">DomainTest</a> the domain is tested. The domain actors
        are started and we create two views with wiretap probes inside to monitor expected messages.
    </p>
        <p>
            <h3>System Test</h3>
<p>
    The <a href="#code/src/test/scala/cqrs/SystemTest.scala" class="shortcut">SystemTest</a> shows how the system works together. In this test we first create a few orders
    by sending commands to the domain. Next we query the View for the top 2 most solled items. This is a cross order view.
    </p>
        <p>
        <h3>Multi-JVM test</h3>
    <p>
        The <a href="#code/src/multi-jvm/scala/cqrs/MultiNodeTest.scala" class="shortcut">MultiNodeTest</a> shows a 2 node setup where one node only runs the Domain and the other
        node only runs the view. This is just an example, as ClusterSharding allows us to add many more Domain Nodes and the same is true for the Read node. We could also run both
        on the same node. This is done in <a href="#code/src/main/scala/cqrs/Main.scala" class="shortcut">Main</a>
        </p>
    </p>


</div>

</body>
</html>
